\documentclass{beamer}
\usepackage[french]{babel}
\usepackage[utf8]{inputenc}
\usepackage{pgfplots}
\usepackage{listings}
%\usetheme{Warsaw}
\title[Projet de programmation et d'algorithmique]{
Algorithme de Strassen et parenthésage optimal
pour la mutliplication de matrices}
\author{Antoine Voizard, Li-yao Xia}
\date{18 décembre 2012}


\begin{document}

\begin{frame}
\titlepage
\end{frame}

\AtBeginSection[]
{
  \begin{frame}<beamer>
    \frametitle{\insertsection}

    \tableofcontents[currentsection]
  \end{frame}
}

\begin{frame}{Introduction}
  Objectifs :
  \begin{itemize}
    \item Ecrire du C.
    \item Faire mieux que les algorithmes naifs.
  \end{itemize}
\end{frame}

\section{Algorithme de Strassen}

\subsection{Principe}
\begin{frame}
  \frametitle{\insertsubsection}
  \begin{itemize}
    \item Multiplication rapide de matrices sur un anneau ;
    (ici, des {\bf int})
    \item Limiter le nombre de multiplications, en taille $2 \times 2$,
    \begin{itemize}
      \item mult. naïve : 8 multiplications scalaires,
      \item mult. de Strassen : 7 multiplications ;
    \end{itemize}
    \item Calcul par blocs, algorithme récursif ;
  \end{itemize}
\end{frame}

\subsection{Implémentation et optimisation}
\begin{frame}[fragile]
  \frametitle{\insertsubsection}
  \framesubtitle{Structures de données}
  \begin{itemize}
    \item Matrice $A$ de taille $m\times n$
    \begin{itemize}
      \item Tableau \verb=A= d'\verb=int=
      (pointeur sur la première case) de taille \verb=m*n=,
      %alloué dynamiquement
      \item Accès à la case $(i,j)$ : \verb=A[i*n+j]= ;
    \end{itemize}
    \item<2-> Sous-matrice $M$ extraite de $A$ de taille $m'\times n'$
    \begin{itemize}
      \item Pointeur sur la première case de $M$ dans \verb=A=,
      \item Largeur de la matrice $A$, \verb=n=,
      \item Accès à la case $(i,j)$ : \verb=M[i*n+j]=.
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{\insertsubsection}
  \small
  \begin{verbatim}
  int* strassen(int* A, int* B, int m, int n, int p);
  \end{verbatim}\normalsize
  Cette fonction prend en argument deux matrices et leurs dimensions,
  et retourne la matrice produit.
\end{frame}

\begin{frame}[fragile]
  \frametitle{\insertsubsection}
  \framesubtitle{Fonctions auxiliaires}
  Prototypes :
  \small\begin{verbatim}
  void _strassen(int* A, int* B, int* C,
                 int m, int n, int p,
                 int width_A, int width_B, int width_C);
  void _addl(int* A, int* B, int* C,
             int m, int n,
             int width_A, int width_B, int width_C);
  \end{verbatim}
  \normalsize
  avec \verb=subl=, \verb=subr= de même prototype que \verb=addr=.

  Ces fonctions effectuent une opération sur deux sous-matrices A et B
  en plaçant le résultat dans C.

  On évite de cette façon de réécrire beaucoup de coefficients.
\end{frame}

\begin{frame}
  \framesubtitle{Addition et soustraction de sous-matrices}
\end{frame}
\subsection{Complexité}
\begin{frame}
  \frametitle{\insertsubsection}
\end{frame}

% Instabilité numérique (flottants)

\subsection{Performance}
\begin{frame}
%insert graph
\end{frame}


\section{Parenthésage optimal}
\subsection{Principe}
\begin{frame}
  \frametitle{\insertsubsection}
  \begin{itemize}
  \item Définition du produit de $n$ matrices
  \item Parenthèsages équivalents
  \item Différents coûts
  \end{itemize}
  
Exemple de coûts : Produit $A_1 \times A_2 \times A_3$
\[
\begin{array}{cc} 
  \mbox{Matrice} & \mbox{Taille}\\
  A_1 & 1000 \times 2\\
  A_2 & 2 \times 8000\\
  A_3 & 8000 \times 400\\
\end{array}
\]
donne :
\[
\begin{array}{cc}
  \mbox{Parenthésage} & \mbox{Coût (algorithme naïf)}\\
  (A_1 \times A_2) \times A_3 & 3.216 \times 10^9\\
  A_1 \times (A_2 \times A_3) & 7.2 \times 10^6
\end{array}
\]
%%% SAMMMMUUUUEEEEELLLL : Vérif stp

  % Un produit de $n$ matrices est défini en se ramenant à $n - 1$ produit de
  % $2$ matrices. Par associativité, on peut effectuer ces produits dans
  % n'importe quel ordre, tant que l'on conserve l'ordre des matrices
  % (c'est-à-dire qu'on essaye pas de les faire commuter).

  % En revanche, le nombre d'opérations effectuées pour les différents
  % parenthésages possibles n'est généralement pas le même. Par exemple :

  % \[\mbox{Soit } A_1, A_2, A_3 \mbox{ des matrices de tailles respectives }
  % 100\times 2, 2 \times 8000, 8000 \times 4\]

\end{frame}

\subsection{Implémentation}
\begin{frame}
  \frametitle{\insertsubsection}
  \begin{itemize}
  \item Détermination récursive des «~coupures~»
  \item Respecte la propriété de sous-structure optimale
  \end{itemize}
\end{frame}
%représentation des données

\subsection{Complexité}
\begin{frame}
  \frametitle{\insertsubsection}
\end{frame}
% A faire :
% Complexité, espace, temps


%%%%%
%%%%% Derniers slides

\begin{frame}{Conclusion}
  Des algorithmes de complexités asymptotiques meilleures
  sont connus pour le parenthésage et la multiplication.

  Mais l'algorithme de Strassen est plus efficace dans les
  applications pratiques. (pour l'instant)
\end{frame}

\end{document}
